<?xml version="1.0" encoding="utf-8"?>
<posts>
<row Id="25914" PostTypeId="1" AcceptedAnswerId="25920" CreationDate="2014-05-20T00:10:19.473" Score="6" ViewCount="1000" Body="&lt;p&gt;Does the following recursive algorithm have a name? If so, what is it?&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;procedure main():&#xA; myFilter = new Filter( myPrime = 2 ) //first prime number&#xA; print 2 //since it would not otherwise be printed&#xA; for each n in 3 to MAX:&#xA;  if myFilter.isPrime(n):&#xA;   print n&#xA;&#xA;object Filter:&#xA; integer myPrime&#xA; PrimeFilter nextFilter = NULL&#xA;&#xA; procedure isPrime(integer n):&#xA;  if n is multiple of myPrime:&#xA;   return FALSE&#xA;  else if nextFilter is not NULL:&#xA;   return nextFilter.isPrime(n)&#xA;  else&#xA;   nextFilter = new PrimeFilter(myPrime = n)&#xA;   return TRUE&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;http://pastebin.com/EFGpvkPT&quot; rel=&quot;nofollow&quot;&gt;Sample implementation in Java here&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This is similar to the Sieve of Eratosthenes though after &lt;a href=&quot;http://chat.stackexchange.com/transcript/message/15610861#15610861&quot;&gt;some discussion in the CS chat&lt;/a&gt;, we decided that it is subtly different.&lt;/p&gt;&#xA;" OwnerUserId="296" LastEditorUserId="296" LastEditDate="2014-06-15T00:52:22.203" LastActivityDate="2014-06-15T00:52:22.203" Title="What is the name of this prime number algorithm?" Tags="&lt;algorithms&gt;&lt;reference-request&gt;&lt;primes&gt;" AnswerCount="2" CommentCount="2" FavoriteCount="1" />
<row Id="24194" PostTypeId="2" ParentId="24186" CreationDate="2014-04-28T18:12:27.417" Score="7" Body="&lt;p&gt;Operator overloading is an example of &lt;em&gt;syntactic sugar&lt;/em&gt; &amp;mdash; a notation that doesn't give any extra power but makes programming easier. I don't know the rationale for the decisions in Java and in Python, but see below. See also &lt;a href=&quot;http://stackoverflow.com/questions/77718/why-doesnt-java-offer-operator-overloading&quot;&gt;this answer&lt;/a&gt; on stackoverflow.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;First, I would like to critique the page you were linking. Let's consider the points raised there one by one.&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;Simplicity and cleanliness: It is claimed that operator overloading slows down the compiler and the JVM (!). This is non-sense. It's plain wrong for the JVM, since this is just syntactic sugar so it wouldn't affect the generated code &lt;em&gt;at all&lt;/em&gt;. As for the compiler, the compiler is already equipped to parse infix operators and to resolve virtual methods, so supporting operator overloading won't make it more complex. On the flip side, operator overloading makes the &lt;em&gt;Java code&lt;/em&gt; simpler and cleaner: compare &lt;code&gt;a.add(b)&lt;/code&gt; to &lt;code&gt;a+b&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Avoid programming errors: It is claimed that non-standard semantics for operators might confuse programmers. Compare this to C++'s use of &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; in streams. I think this point is valid but overstated. The same point could be made with regard to other conventions. It's up to the programmers to not abuse the capabilities of the language.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;JVM complexity: It is claimed that operator overloading complicates the JVM. As stated above, at the JVM level there would be absolutely no difference.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Easy development of tools: It is claimed that operator overloading complicated the design of IDEs. The answer here is very similar to the answer to the first point. The only complication with operator overloading is that you have to figure out the type of the operands, but presumably if it makes any difference you would need to do it anyway since there are also several different &lt;em&gt;number&lt;/em&gt; types, say integer and floating point.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;A point which is not raised is that operator overloading might complicate optimization since certain algebraic identities hold for numbers but not in general. This criticism is wrong for the following reason: algebraic identities cannot in general be used even for &lt;em&gt;floating-point&lt;/em&gt; computations, since order of operations makes a difference. So the compiler needs to determine the type of the operands anyway, and could easily abstain from optimizing user defined operators.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The Python philosophy is to supply the coders with the rope to hang themselves. If you're a good coder, you will use the rope for good, say for tying your bicycle in the train, rather than to hang yourself or anybody else. Python trusts programmers more than Java, &lt;em&gt;by design&lt;/em&gt;. See the second point above.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Let me end this answer by quoting &lt;a href=&quot;http://stackoverflow.com/a/194889&quot;&gt;an excellent answer&lt;/a&gt; to the stackoverflow question mentioned above:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;I left out operator overloading as a fairly personal choice because I had seen too many people abuse it in C++.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;James Gosling. Source: &lt;a href=&quot;http://www.gotw.ca/publications/c_family_interview.htm&quot;&gt;http://www.gotw.ca/publications/c_family_interview.htm&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Many C++ design decisions have their roots in my dislike for forcing people to do things in some particular way [...] Often, I was tempted to outlaw a feature I personally disliked, I refrained from doing so because I did not think I had the right to force my views on others.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Bjarne Stroustrup. Source: The Desing and Evolution of C++ (1.3 General Background)&lt;/p&gt;&#xA;" OwnerUserId="683" LastActivityDate="2014-04-28T18:12:27.417" CommentCount="1" />
<row Id="6787" PostTypeId="2" ParentId="6782" CreationDate="2012-11-20T15:12:28.310" Score="6" Body="&lt;p&gt;I suspect that this is intimately related to &lt;em&gt;shadowing&lt;/em&gt; of fields in Java.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;When writing a derived class, I can, as in your example, write a field &lt;code&gt;x&lt;/code&gt; that shadows the definition of &lt;code&gt;x&lt;/code&gt; in the base class. This means that in the derived class, the original definition is no longer accessible via name &lt;code&gt;x&lt;/code&gt;. The reason Java allows this is so that derived class implementations are less dependent on the base class implementation details, thereby (only partially) avoiding the fragile base class problem. For instance, if the base class did not originally have a field &lt;code&gt;x&lt;/code&gt;, but then subsequently introduced one, Java's semantics avoid this breaking the derived class implementation.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The variable &lt;code&gt;x&lt;/code&gt; in the derived class can have a completely different type than the variable in the base class â€“ I tested this, it works. This is in stark contrast to method overriding, where the type needs to be sufficiently compatible (aka, the same). So when I have a variable of type &lt;code&gt;A&lt;/code&gt; in your example, the only type I can derive for it is the one specified in class &lt;code&gt;A&lt;/code&gt; (or above). As this can be different from the type declared in class &lt;code&gt;B&lt;/code&gt;, it is only type safe to return the value of the field &lt;code&gt;x&lt;/code&gt; from class &lt;code&gt;A&lt;/code&gt;. (And naturally, the semantics must be the same regardless of what the type of the field is in class &lt;code&gt;B&lt;/code&gt;.)&lt;/p&gt;&#xA;" OwnerUserId="31" LastEditorUserId="31" LastEditDate="2012-11-20T15:23:41.713" LastActivityDate="2012-11-20T15:23:41.713" CommentCount="6" />
<row Id="29476" PostTypeId="2" ParentId="29475" CreationDate="2014-08-28T21:08:09.387" Score="40" Body="&lt;p&gt;I immediately recalled an example from &lt;a href=&quot;http://en.wikipedia.org/wiki/Roland_Carl_Backhouse&quot;&gt;R. Backhouse&lt;/a&gt; (this might have been in one of his books). Apparently, he had assigned a programming assignment where the students had to write a Pascal program to test equality of two strings. One of the programs turned in by a student was the following:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;issame := (string1.length = string2.length);&#xA;&#xA;if issame then&#xA;  for i := 1 to string1.length do&#xA;    issame := string1.char[i] = string2.char[i];&#xA;&#xA;write(issame);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;We can now test the program with the following inputs: &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&quot;university&quot; &quot;university&quot; $\Rightarrow$ True; OK&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&quot;course&quot; &quot;course&quot; $\Rightarrow$ True; OK&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&quot;&quot; &quot;&quot; $\Rightarrow$ True; OK&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&quot;university&quot; &quot;course&quot; $\Rightarrow$ False; OK&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&quot;lecture&quot; &quot;course&quot; $\Rightarrow$ False; OK&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&quot;precision&quot; &quot;exactness&quot; $\Rightarrow$ False, OK&lt;/p&gt;&#xA;&#xA;&lt;p&gt;All of this seems very promising: maybe the program does indeed work. But a more careful testing with say &quot;pure&quot; and &quot;true&quot; reveals faulty output. In fact, the program says &quot;True&quot; if the strings have the same length and the same last character!&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, testing had been pretty thorough: we had strings with different length, strings with equal length but different content, and even equal strings. Furthermore, the student had even tested and executed every branch. You can't really argue testing had been careless here -- given that the program is indeed very simple, it might be hard to find the motivation and energy to test it thoroughly enough.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;Another cute example is binary search. In TAOCP, Knuth says that &quot;although the basic idea of binary search is comparatively straightforward, the details can be surprisingly tricky&quot;. Apparently, a bug in the binary search implementation of Java went unnoticed for a decade. It was an integer overflow bug, and only manifested with large enough input. Tricky details of binary search implementations are also covered by Bentley in the book &lt;em&gt;Programming Pearls&lt;/em&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Bottom line: it can be surprisingly hard to be certain a binary search algorithm is correct by just testing it.&lt;/p&gt;&#xA;" OwnerUserId="472" LastEditorUserId="472" LastEditDate="2014-09-04T06:17:57.430" LastActivityDate="2014-09-04T06:17:57.430" CommentCount="6" />
<row Id="48888" PostTypeId="1" CreationDate="2015-10-30T00:37:50.137" Score="0" ViewCount="30" Body="&lt;p&gt;Lately graph theory has come into everyday practice with graph databases. So I wonder if any object can be written as a graph? I don't have the formal definition of an object, but say it is a C &lt;code&gt;struct&lt;/code&gt; or a Java &lt;code&gt;Object&lt;/code&gt;, isn't it so that we can express objects as graphs and that it is a more convenient and advantageous representation than an algebraic relational representation (rdbms)?&lt;/p&gt;&#xA;" OwnerUserId="2529" LastActivityDate="2015-10-30T00:37:50.137" Title="Can any object be written as a graph?" Tags="&lt;graph-theory&gt;&lt;object-oriented&gt;" AnswerCount="0" CommentCount="2" />
<row Id="3405" PostTypeId="2" ParentId="1693" CreationDate="2012-09-02T20:10:06.257" Score="5" Body="&lt;p&gt;Just an idea: you can use scientific libraries written in Java (I think you'll find a lot of work already available) with Javascript - that has a syntax similar to Java - used only as a wrapping language for:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;scripting&lt;/li&gt;&#xA;&lt;li&gt;user interaction &lt;/li&gt;&#xA;&lt;li&gt;(re)modeling and standardization of the underlying high level classes/packages/functions ... though I think it would be better to do this in the Java &quot;layer&quot;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;See the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Rhino&quot; rel=&quot;nofollow&quot;&gt;Rhino project&lt;/a&gt; for a stable Javascript interpreter written in Java.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you want you can use the Java JNI to use scientific libraries written in C/C++.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The whole picture:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;                              ____ disparate Java libraries&#xA;Javascript   ----- Java      /&#xA;(scripting,      (&quot;package   \____ JNI ____ C/C++ libraries&#xA; interaction,     remodeling&quot;)   &#xA;high-level stuff)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;EDIT&lt;/strong&gt;: just Googling around a found stuff like this: &lt;a href=&quot;http://sourceforge.net/projects/jgsl/&quot; rel=&quot;nofollow&quot;&gt;Java GNU Scientific library&lt;/a&gt;, &lt;a href=&quot;http://en.wikipedia.org/wiki/List_of_numerical_libraries#Java&quot; rel=&quot;nofollow&quot;&gt;List of (Java) numerical libraries&lt;/a&gt;, &lt;a href=&quot;https://github.com/jgrapht/jgrapht&quot; rel=&quot;nofollow&quot;&gt;Java Graph library&lt;/a&gt;, &lt;a href=&quot;http://jwork.org/jhepwork/&quot; rel=&quot;nofollow&quot;&gt;jHepWork&#xA;  Multiplatform environment for scientific computation and data analysis&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="140" LastEditorUserId="140" LastEditDate="2012-09-02T20:33:19.803" LastActivityDate="2012-09-02T20:33:19.803" CommentCount="1" />
<row Id="238" PostTypeId="2" ParentId="231" CreationDate="2012-03-12T14:59:31.900" Score="4" Body="&lt;p&gt;We can look at how closures are implemented in C#. The scale of the transformations the C# compiler performs makes it clear that their way of implementing closures is quite a lot of work. There may be easier ways to implement closures, but I'd think the C# compiler team would be aware of this.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Consider the following pseudo-C# (I cut out a bit of C# specific stuff):&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;int x = 1;&#xA;function f = function() { x++; };&#xA;for (int i = 1; i &amp;lt; 10; i++) {&#xA;    f();&#xA;}&#xA;print x; // Should print 9&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;The compiler transforms this into something like this:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;class FunctionStuff {&#xA;   int x;&#xA;   void theFunction() {&#xA;       x++;&#xA;   }&#xA;}&#xA;&#xA;FunctionStuff theClosureObject = new FunctionStuff();&#xA;theClosureObject.x = 1;&#xA;for (int i = 1; i &amp;lt; 10; i++) {&#xA;    theClosureObject.theFunction();&#xA;}&#xA;print theClosureObject.x; // Should print 9&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;(in reality, the variable f will still be created, where f is a 'delegate' (= function pointer), but this delegate is still associated with the theClosureObject object - I left this part out for clarity for those that aren't familiar with C#)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This transformation is quite massive and tricky: consider closures inside closures and the interplay of closures with the rest of the C# language features. I can imagine that the feature was pushed back for Java, as Java 7 already has quite a lot of new features.&lt;/p&gt;&#xA;" OwnerUserId="92" LastEditorUserId="92" LastEditDate="2012-03-12T15:09:37.153" LastActivityDate="2012-03-12T15:09:37.153" CommentCount="3" />
<row Id="48788" PostTypeId="2" ParentId="48782" CreationDate="2015-10-28T02:09:09.593" Score="3" Body="&lt;p&gt;&quot;Local variable&quot; is a concept in the source language. Some target languages have the concept (e.g. virtual machines with dictionary-based scopes), but many do not. Since you're using Java, let's look at the JVM.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A local variable cannot be accessed by other methods (e.g. you can't pass a variable by reference like you can in C++ or Fortran), and cannot be accessed by other threads. This gives a Java compiler (and a JVM implementation, for that matter) a lot of freedom about what to do with it.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;JVM code has two &quot;local&quot; areas where it may store data: the &lt;em&gt;operand stack&lt;/em&gt; and the &lt;em&gt;local variable array&lt;/em&gt;. If you want to read along, this is covered in &lt;a href=&quot;http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.6&quot; rel=&quot;nofollow&quot;&gt;section 2.6 of the JVM specification&lt;/a&gt;. As the names suggest, the operand stack is organised like a stack (mostly push and pop-type operations), and the local variable array is organised like an array (dereference-type operations).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The JVM is designed so that a compiler can emit code where every local variable has one exactly entry in the local variable array. To use the value, the compiler would emit code to transfer a value from the local variable array to the stack (the instruction is called &quot;load&quot;; there are variants for variables of different types, but we'll ignore this complication for now), and to write a value to the variable, there is a corresponding &quot;store&quot; instruction which transfers a value from the stack to the local variable array. &lt;a href=&quot;http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-3.html#jvms-3.2&quot; rel=&quot;nofollow&quot;&gt;Section 3.2 of the specification covers this.&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The reason why the JVM is designed with this in mind is that it allows for very simple compilers. However, this is not the only possible way to generate code for the JVM.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A local variable cannot be accessed by another method (e.g. you can't pass it by reference like you can in C++), or on another thread. So the compiler has a lot of freedom about what it can do with one.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If a variable is extremely short-lived, for example, it may not need an entry in the local variable array. Consider, for example:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;for (int i = 0; i &amp;lt; 10; ++i) {&#xA;    int x = f(i);&#xA;    g(x,x);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;A simple way of compiling the body of this loop might be something like this.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// x = f(i);&#xA;iload i    // push i onto the stack&#xA;invoke f   // pop the argument, call f, and then push the return value on the stack&#xA;istore x   // pop the stack and store the value in local variable x&#xA;// g(x,x);&#xA;iload x    // This probably doesn't need to be explained, right?&#xA;iload x&#xA;invoke g&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;(Note that this isn't actually JVM bytecode. The JVM uses slot numbers in the bytecode stream, not names, and also has different &quot;invoke&quot; instructions depending on what &quot;f&quot; actually is; it might be a static method, or an interface method, or one of a number of other things. Nonetheless, this should give you the basic idea.)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The variable x doesn't really need to be stored in the local variable array. When this method calls the method f(), the return value is pushed onto the operand stack. Invoking the method g() requires two values to be on the top of the operand stack, representing its arguments. The JVM has an instruction (called &quot;dup&quot;) which duplicates the value on the top of the operand stack, so the body of this loop could be compiled as:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;iload i&#xA;invoke f&#xA;dup        // Duplicate the top value on the stack&#xA;invoke g&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;In fact, in this simple example, the compiler may not need to allocate local storage for i, either.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There are lots of other possibilities. The compiler might reuse local storage slots for local variables whose lifetimes don't overlap, or it might assign different locations to the same variable for different parts of the code; this is known as &lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.49.4451&amp;amp;rep=rep1&amp;amp;type=pdf&quot; rel=&quot;nofollow&quot;&gt;live range splitting&lt;/a&gt;. In a sense, the distinction between the operand stack and the local variable array when compiling for the JVM is very like the distinction between registers and the stack when compiling for a physical CPU, and many of the same ideas carry across.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now, there are a few reasons why a compiler might not want to go to all this trouble.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;First off, it can be a lot of work. Optimal register allocation is a formally unsolvable problem, although for some reasonable definitions of &quot;optimal&quot; it's NP-complete. Nonetheless, for stack machines like the JVM, very simple techniques work in practice.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Secondly, chances are good that if this is performance-critical code, it will be JIT-compiled anyway, and so many of these optimisations will be done by that part of the JVM implementation.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Thirdly, it complicates debugging. If a variable can be stored in more than one location, then the debugger needs to know where to find the value any point in the program. If the reason why you're optimising local variable storage is to reduce the size of the class file, chances are good that it won't help, because what you gain in the number of instructions you will probably lose in debugger metadata.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This is one reason why software projects often use &quot;debug builds&quot; during development.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;One final thing: I've been talking about basic types like integers here, but one additional complication in optimising the storage of local variables is how it interacts with the garbage collector, since the garbage collector needs to know what heap objects are referred to by local variables.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Garbage collection is a more advanced topic, and you didn't ask about it, so I won't go into the details. It doesn't affect how a Java compiler would compile to JVM bytecode, but it may affect the design of the JVM implementation. Once again, a local variable can't be accessed by other methods or other threads, so this gives the JVM implementation a lot of freedom on how it can let the garbage collector know what is live and what isn't.&lt;/p&gt;&#xA;" OwnerUserId="6553" LastEditorUserId="6553" LastEditDate="2015-10-28T05:15:57.163" LastActivityDate="2015-10-28T05:15:57.163" CommentCount="0" />
<row Id="49014" PostTypeId="1" CreationDate="2015-11-03T02:51:05.937" Score="1" ViewCount="22" Body="&lt;p&gt;I have written an algorithm for sorting that I thought of, and I'm not sure if it exists.  Basically, it runs through each index of an array and if the value of index n &gt; the value of the index n+1, they get swapped.  My java code is below.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Here is the example of it running on an array of length 4.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;(Given) [3,2,7,5]&#xA;(Step 1 [first loop]) [2,3,7,5]&#xA;(Step 1 [second iteration]) [2,3,7,5] (3&amp;lt;7, so no change)&#xA;(Step 1 [third iteration]) [2,3,5,7]&#xA;Sorted array detected, stopped.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;This is my Java.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;  public static int length = 10;&#xA;public static int[] data = new int[10];&#xA;public static void main(String[] args) {&#xA;    Scanner scan = new Scanner(System.in);&#xA;    // TODO Auto-generated method stub&#xA;&#xA;    data[0] = 1;&#xA;    data[1] = 10;&#xA;    data[2] = 5;&#xA;    data[3] = 11;&#xA;    data[4] = 9;&#xA;    data[5] = 2;&#xA;    data[6] = 7;&#xA;    data[7] = 9;&#xA;    data[8] = 8;&#xA;    data[9] = 10;&#xA;    printstar();&#xA;    System.out.println();&#xA;    while(inOrder()){&#xA;        exchange();&#xA;        printstar();&#xA;    }&#xA;&#xA;&#xA;&#xA;}&#xA;&#xA;public static void exchange(){&#xA;    int temp = 0;&#xA;    for(int i=0;i&amp;lt;length-1;i++){&#xA;        if(data[i] &amp;gt; data[i+1]){&#xA;            temp = data[i+1];&#xA;            data[i+1] = data[i];&#xA;            data[i] = temp;&#xA;        }&#xA;    }&#xA;}&#xA;&#xA;public static boolean inOrder(){&#xA;    for(int i = 0; i&amp;lt;length-1;i++){&#xA;        if(data[i] &amp;gt; data[i+1]){&#xA;            return true;&#xA;        }&#xA;    }&#xA;    return false;&#xA;}&#xA;&#xA;public static void printstar(){&#xA;    for (int i =0; i &amp;lt; length; i++){&#xA;        System.out.print(data[i]+ &quot; &quot;);&#xA;    }&#xA;    System.out.println();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;To clarify, &lt;code&gt;printstar()&lt;/code&gt; prints the array.  &lt;code&gt;inOrder()&lt;/code&gt; returns true if the array is not in order.  Returns false if it is in order.  &lt;code&gt;exchange()&lt;/code&gt; changes the values.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;In summary, has a swapping algorithm like this been used before?&lt;/strong&gt;&lt;/p&gt;&#xA;" OwnerUserId="41891" LastEditorUserId="41891" LastEditDate="2015-11-03T04:02:10.210" LastActivityDate="2015-11-03T04:02:10.210" Title="Sorting Algorithm Existence" Tags="&lt;algorithms&gt;&lt;sorting&gt;" AnswerCount="0" CommentCount="5" ClosedDate="2015-11-03T03:55:24.993" />
 <row Id="20188" PostTypeId="2" ParentId="20181" CreationDate="2014-02-01T15:40:14.350" Score="2" Body="&lt;p&gt;Any modern compiler consists of multiple phases, at least&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Lexical_analysis&quot; rel=&quot;nofollow&quot;&gt;lexing&lt;/a&gt;,&lt;/li&gt;&#xA;&lt;li&gt;(context-free) &lt;a href=&quot;https://en.wikipedia.org/wiki/Parsing&quot; rel=&quot;nofollow&quot;&gt;parsing&lt;/a&gt; and&lt;/li&gt;&#xA;&lt;li&gt;target code generation.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;Additional phases are static analysis (names, types, ...) and optimisations.&#xA;Each phase uses the result of the prior as input.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now, the lexer processes the actual program text and transforms it into a token stream. For instance, the (sub)string &lt;code&gt;&quot;abc&quot;&lt;/code&gt; becomes a token &lt;code&gt;StringLiteral(&quot;abc&quot;)&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt; becomes &lt;code&gt;IF&lt;/code&gt; and &lt;code&gt;myMethod&lt;/code&gt; becomes &lt;code&gt;Identifier(&quot;myMethod&quot;)&lt;/code&gt;. Tokens typically hold additional information, e.g. their position in the original program text. The context-free grammar used for syntax parsing is expressed in terms of these tokens, usually ignoring their parameters.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;At this point, it should be clear that handling whitespace is nothing crazy: instead of dropping all whitespace (like a Java compiler would do), you could as easily lex the strings &lt;code&gt;&quot;  &quot;&lt;/code&gt; or &lt;code&gt;\t&lt;/code&gt; to a token &lt;code&gt;Indentation&lt;/code&gt; used in the grammar.&lt;/p&gt;&#xA;" OwnerUserId="98" LastActivityDate="2014-02-01T15:40:14.350" CommentCount="0" />
</posts>